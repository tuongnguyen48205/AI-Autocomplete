# AI-Autocomplete
The recent success of generative tools has spawned many new applications and debates in society. A generative tool is trained on a massive dataset, for example, pictures or texts. Then, given a new input, referred to as a prompt, patterns in the prompt get matched to the frequent patterns in the model learned by the tool, and the contextual extensions of the recognized pattern get generated. This is a tool for generating text statements from prompts. In the first version of the tool, it learns a frequency prefix automaton from training statements. In the automaton, nodes are annotated with unique identifiers and frequencies with which they were observed during training, and arcs are annotated with statement fragments. For instance, the root of the automaton has identifier 0. Given a prompt, for example, “Hi”, the tool should identify the context by replaying the prompt starting from the initial node of the automaton. Then, given the context, the tool should generate the most likely extension of the prompt, that is, the extension that follows the most frequent subsequent nodes. 

The program reads input from stdin and writes output to stdout. The input is a list of statements, instructions, and prompts, each terminating either with '\n', that is, one newline character, or EOF, that is, the end of the file constant defined in the <stdio.h> header file. The input always starts with statements, each provided as a non-empty sequence of characters. If the line that follows the input statements is empty, that is, consists of a single newline character, it is the instruction to proceed to stage 1 of the program. Subsequent lines in the input specify prompts, one per line, to be processed in stage 1. The prompts can be followed by another empty line, which denotes the instruction to proceed to stage 2. The stage 2 input starts with the instruction to compress input statements, given as a non-negative integer, followed by prompts to be processed in stage 2 of the program. In general, the input can contain an arbitrary number of statments and prompts. The input will always follow the proposed format. 

Stage 0:
The first version of the program will read statements from input, constructing a prefix automaton and print basic information about the automaton output. Line 1 of the output prints the stage 0 header. Line 2 and 3 print the total number of statements and the total number of characters in all the statements read from the input, respectively. Finally, line 4 reports the number of nodes, also called states, in the frequency prefix automaton constructed from the input statements. Nodes of an automaton are states, each with a unique identifier, while arcs encode characters. Note that state identifiers are used for presentation only and do not impact the output the tool generates. In an automaton, the node without incoming arcs is the initial state, and a node without outgoing arcs is a leaf state. The characters encountered on the arcs traversed on a walk from the initial state to a leaf state (without visiting thee same state twice) define a statement. The statements defined by an automaton are all and only statements the automaton was constructed from. States are annotated with frequencies of traversing, that is, arriving to and departing from, them when performing all the walks that define the statements used to construc the automaton. The leaf state is annotated with the frequency of zero. For any two statements, the resulting automaton reuses the states and arcs that correspond to their longest common prefix.

Stage 1:
The output of stage 1 of the program will start with the header. This is an extension from stage 0. To process a prompt, it is first replayed on the automaton, and then the continuation of the prompts is generated. The replay of a prompt starts in the initial state and follows the arcs that correspond to the characters in the prompt. While following the arcs, the encountered characters should be printed to stdout. If the entire prompt was replayed, print the ellipses (a series of three dots) to denote the start of text generation. To generate text, one proceeds with the walk from the state reached during the replay to a leaf state by selecting the most frequent following states. If, at some encountered state, two or more next states have the same frequency, the one that is reached via the ASCIIbetically greater label on the arc (the label with the first non-matching character greater in ASCII) should be chosen. Again, the characters encountered along the arcs should be printed to stdout. If the automaton does not support a replay of the entire prompt, the output should be terminated once the first non-supported character is encountered. The replayed characters must be appended by the ellipses in the output, and no generation must be performed. Every output triggered by an input prompt, including the replay, ellipses, and the generated characters, should be truncated to 37 characters.

Stage 2:
The output of stage 2 of the program will start with the header line. This stage will compress the automaaaton obtained in stage 1 and use the compressed automaton to process the input prompts of stage 2. The first line of the input of Stage 2 specifies the number of compression steps to perform. Each next compression step should be performed on the automaton resulting from all the previous compression steps. A single compression step of an automaton is defined by its arc. To find the arc that defines the next compression step to perform, traverse the automaton states starting from the initial state in the depth-first order, prioritizing states reachable via smaller (in ASCII) labels. The arc between the currently visited state x and the next visited state y in the traversal of the states leads to the next compression step if: (i) x has a single outgoing arc and (ii) y has one or more outgoing arcs. The compression step is performed by first adding a new arc from x to every state reachable from y via an outgoing arc and then deleting y and all arcs that connect to y. The label of an added arc is the concatenation of the labels of the deleted arcs on the walk from the source to the target of this new arc in the original automaton. The prompt replay and extension generation in Stage 2 must follow the corresponding principles described in Stage 1 but should be performed on the compressed automaton. The output should report the number of states in the compressed automaton, the sum of frequencies of all the states in the compressed automaton, and all the generated statements after the delimiter line of 37 “-” characters. Every run of your program should terminate by printing the end message.
